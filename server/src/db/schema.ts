
import {
  pgTable,
  varchar,
  bigint,
  text,
  timestamp,
  pgEnum,
  index,
} from 'drizzle-orm/pg-core';

/**
 * Transaction Type Enum
 *
 * Defines whether this is an invoice (receiving payment) or payment (sending payment).
 * Using pgEnum creates a PostgreSQL ENUM type for data integrity.
 */
export const transactionTypeEnum = pgEnum('transaction_type', [
  'invoice',
  'payment',
]);

/**
 * Transaction Status Enum
 *
 * Tracks the lifecycle of a Lightning transaction:
 * - pending: Created but not yet completed
 * - succeeded: Payment successful
 * - failed: Payment failed
 * - expired: Invoice expired before payment
 */
export const transactionStatusEnum = pgEnum('transaction_status', [
  'pending',
  'succeeded',
  'failed',
  'expired',
]);

/**
 * Transactions Table Schema
 *
 * This table stores all Lightning Network transactions (both invoices and payments).
 *
 * Design decisions:
 * 1. payment_hash as primary key: Unique identifier for Lightning payments
 * 2. Single table for invoices and payments: Simplifies tracking payment flow
 * 3. Timestamps with defaults: Automatic tracking of creation and updates
 * 4. Nullable fields: Some fields only apply to certain transaction types
*/
export const transactions = pgTable(
  'transactions',
  {
    // Primary key: Unique payment hash (32-byte hex string)
    // This is generated by the Lightning Network and identifies the payment
    paymentHash: varchar('payment_hash', { length: 64 }).primaryKey(),

    // Transaction type: 'invoice' or 'payment'
    transactionType: transactionTypeEnum('transaction_type').notNull(),

    // Amount in satoshis
    // Using bigint because amounts can be very large (up to 21 million BTC)
    amount: bigint('amount', { mode: 'number' }).notNull(),

    // Current status of the transaction
    status: transactionStatusEnum('status').notNull().default('pending'),

    // BOLT11 invoice string (Lightning payment request)
    // Example: lnbcrt10n1p3...
    // Null for payments (they reference an external invoice)
    paymentRequest: text('payment_request'),

    // Payment preimage (proof of payment)
    // When a payment succeeds, this proves it was completed
    // Hash(preimage) = paymentHash (this is how Lightning ensures atomicity)
    preimage: varchar('preimage', { length: 64 }),

    // Optional human-readable description
    // Example: "Coffee", "Invoice #123"
    description: text('description'),

    // Which node this transaction belongs to
    // 'node_a' = receiver (generates invoices)
    // 'node_b' = sender (makes payments)
    nodeId: varchar('node_id', { length: 50 }).notNull(),

    // When the invoice expires (for invoices only)
    // Lightning invoices typically expire after 1 hour
    expiresAt: timestamp('expires_at', { withTimezone: true }),

    // When this record was created in our database
    createdAt: timestamp('created_at', { withTimezone: true })
      .defaultNow()
      .notNull(),

    // When this record was last updated
    // Will be automatically updated via trigger or application logic
    updatedAt: timestamp('updated_at', { withTimezone: true })
      .defaultNow()
      .notNull(),
  },
  (table) => {
    // Indexes for faster queries
    // These speed up WHERE clauses and sorting
    return {
      // Index for filtering by transaction type
      typeIdx: index('idx_transactions_type').on(table.transactionType),

      // Index for filtering by status
      statusIdx: index('idx_transactions_status').on(table.status),

      // Index for filtering by node
      nodeIdx: index('idx_transactions_node').on(table.nodeId),

      // Index for sorting by creation date (most recent first)
      createdIdx: index('idx_transactions_created').on(table.createdAt),

      // Composite index for common query pattern:
      // "Get all invoices for node_a, ordered by date"
      nodeTypeCreatedIdx: index('idx_transactions_node_type_created').on(
        table.nodeId,
        table.transactionType,
        table.createdAt
      ),
    };
  }
);

/**
 * TypeScript Type Inference
 *
 * Drizzle automatically infers TypeScript types from the schema.
 * These types are used throughout the application for type safety.
 */

// Type for inserting a new transaction (all fields with defaults are optional)
export type NewTransaction = typeof transactions.$inferInsert;

// Type for selecting a transaction (represents a full row)
export type Transaction = typeof transactions.$inferSelect;
